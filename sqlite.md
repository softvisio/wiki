# SQLite

### Field with the current unix timestamp by default

```sql
"unix_timestamp" integer NOT NULL DEFAULT(strftime('%s', 'NOW'))
"unix_timestamp_hires" float NOT NULL DEFAULT(time_hires())
```

### Field with the current timestamp by default

```sql
"timestamp" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
"timestamp_with_milliseconds" timestamp NOT NULL DEFAULT(strftime('%Y-%m-%d %H:%M:%f', 'NOW'))
```

### Autogenerated UUID

```sql
DEFAULT(uuid_generate_v1mc())
DEFAULT(uuid_generate_v4())
DEFAULT(gen_random_uuid())
```

### Notifications

```sql
SELECT sqlite_notify( 'event-name', payload );
```

### FAQ

SQLite will NOT use the second column of an index if the first column was an inequality expression (eg. customer > 33).

If you create two separate indices, only one of them will be used, the other expression will be evaluated on the result set generated by the first. (on an Oracle, it could execute the two index search and intersect the result sets, if optimization is cost based and certain criteria meets, but thats a rare case).
